import { Command } from 'commander';
import chalk from 'chalk';
import ora from 'ora';
import { existsSync, readFileSync, writeFileSync, mkdirSync } from 'fs';
import { resolve, join, dirname } from 'path';
import { loadConfig, getStrings, escapeHtml } from '@codedocs/core';
import type { Locale } from '@codedocs/core';
import { getCliStrings, t, initLocale } from '../i18n.js';
import { buildStaticPages } from '@codedocs/vite-plugin';
import { runSubprocess } from '../utils/run-subprocess.js';
import {
  type NavItem,
  type TocHeading,
  getRelativePrefix,
  buildTopNav,
  addHeadingIds,
  extractTocHeadings,
  buildNavHtml,
  buildTocHtml,
  buildLeftSidebar,
  buildBreadcrumb,
  buildDashboardContent,
  buildMemoPageContent,
  decorateMermaidBlocks,
  sanitizeHtmlContent,
  rewriteInternalLinks,
} from './build-helpers.js';
import { getStylesheet, renderRuntimeScripts } from './build-assets.js';

export const buildCommand = new Command('build')
  .description('Build production-ready documentation site')
  .option('-c, --config <path>', 'Path to config file', 'codedocs.config.ts')
  .option('--skip-analyze', 'Skip analysis step')
  .option('--skip-generate', 'Skip generation step')
  .option('--verbose', 'Show detailed build output')
  .option('--docs-dir <path>', 'Input docs directory', './docs-output')
  .option('-o, --output <path>', 'Output directory for built site', './dist')
  .action(async (options) => {
    const s = getCliStrings().cli;
    console.log(chalk.bold.cyan(`\nüèóÔ∏è  ${s.buildTitle}\n`));

    try {
      // Load config
      const configPath = resolve(process.cwd(), options.config);
      if (!existsSync(configPath)) {
        console.error(chalk.red(`${s.configNotFound}: ${options.config}\n`));
        process.exit(1);
      }

      const config = await loadConfig(configPath);
      initLocale(config.docs?.locale);
      const strings = getCliStrings().cli;
      const outDir = options.output;

      // Step 1: Analyze
      if (!options.skipAnalyze) {
        await runSubprocess('analyze', ['analyze', '-c', options.config], { verbose: options.verbose });
      } else {
        console.log(chalk.dim(`‚äò ${strings.skippingAnalysis}\n`));
      }

      // Step 2: Generate
      if (!options.skipGenerate) {
        await runSubprocess('generate', ['generate', '-c', options.config], { verbose: options.verbose });
      } else {
        console.log(chalk.dim(`‚äò ${strings.skippingGeneration}\n`));
      }

      // Step 3: Build static HTML site
      console.log(chalk.cyan(strings.buildingSite));
      const spinner = ora(strings.buildingSite).start();
      await buildStaticSite(options.docsDir, outDir, config);
      spinner.succeed(strings.buildComplete);

      // Summary
      console.log(chalk.green(`\n‚úì ${strings.buildComplete}\n`));
      console.log(chalk.dim(`  ${t(strings.outputDirectory, { dir: outDir })}`));
      console.log(chalk.cyan(`\n${strings.nextSteps}`));
      console.log(chalk.dim(`  - ${t(strings.deployHint, { dir: outDir })}`));
      console.log(chalk.dim(`  - ${strings.previewLocalHint}\n`));
    } catch (error) {
      console.error(chalk.red(`\n‚úó ${getCliStrings().cli.buildFailed}\n`));
      console.error(chalk.red((error as Error).message));
      process.exit(1);
    }
  });

async function buildStaticSite(docsDir: string, outDir: string, config: any): Promise<void> {
  const docsPath = resolve(process.cwd(), docsDir);
  const distPath = resolve(process.cwd(), outDir);

  if (!existsSync(docsPath)) {
    throw new Error(`Documentation directory not found: ${docsDir}. Run "codedocs generate" first.`);
  }

  // Create dist directory
  if (!existsSync(distPath)) {
    mkdirSync(distPath, { recursive: true });
  }

  // Collect and render markdown files through shared SSG pipeline
  const ssgPages = await buildStaticPages(docsPath);
  if (ssgPages.length === 0) {
    throw new Error(`No markdown files found in ${docsDir}`);
  }

  // Get locale strings
  const locale = (config.docs?.locale || 'en') as Locale;
  const s = getStrings(locale);

  // Build navigation model
  const pages = ssgPages.map((page) => {
    const position = page.meta.sidebar_position ? Number(page.meta.sidebar_position) : 999;
    return {
      slug: page.slug,
      title: page.title,
      html: page.html,
      meta: page.meta,
      position,
    };
  });

  // Sort pages by sidebar position
  pages.sort((a, b) => a.position - b.position);

  // Load sidebar structure from _sidebar.json (generated by SidebarGenerator)
  const sidebarJsonPath = join(docsPath, '_sidebar.json');
  const sidebarStructure = existsSync(sidebarJsonPath)
    ? JSON.parse(readFileSync(sidebarJsonPath, 'utf-8'))
    : null;

  // Get project name from config
  const projectName = config.name || config.docs?.title || 'Documentation';

  // Collect all known slugs for link rewriting
  const knownSlugs = new Set(pages.map(p => p.slug));

  // Generate HTML for each page
  for (const page of pages) {
    const htmlContent = decorateMermaidBlocks(page.html);
    // Rewrite internal .md links to .html and fix directory links
    const rewrittenContent = rewriteInternalLinks(htmlContent, knownSlugs);
    const sanitizedContent = sanitizeHtmlContent(rewrittenContent);
    const contentWithIds = addHeadingIds(sanitizedContent);
    const tocHeadings = extractTocHeadings(contentWithIds);
    const basePrefix = getRelativePrefix(page.slug);
    const navItems = sidebarStructure
      ? buildTopNav(sidebarStructure, basePrefix, page.slug, s)
      : pages.map(p => ({ label: p.title, href: `${basePrefix}${p.slug}.html`, active: p.slug === page.slug }));
    const htmlPage = generateHtmlPage({
      title: page.title,
      projectName,
      content: contentWithIds,
      navItems,
      tocHeadings,
      currentSlug: page.slug,
      pageId: page.slug,
      locale,
      s,
      basePrefix,
      sidebarStructure: sidebarStructure || [],
    });

    const outFile = join(distPath, `${page.slug}.html`);
    const outFileDir = dirname(outFile);
    if (!existsSync(outFileDir)) {
      mkdirSync(outFileDir, { recursive: true });
    }
    writeFileSync(outFile, htmlPage, 'utf-8');
  }

  // Generate index.html that redirects to the index page or first page
  const indexPage = pages.find(p => p.slug === 'index') || pages[0];
  if (indexPage && indexPage.slug !== 'index') {
    // Create redirect index.html
    writeFileSync(
      join(distPath, 'index.html'),
      `<!DOCTYPE html><meta http-equiv="refresh" content="0;url=./${indexPage.slug}.html">`,
      'utf-8'
    );
  }

  // Write CSS file
  const assetsDir = join(distPath, 'assets');
  if (!existsSync(assetsDir)) {
    mkdirSync(assetsDir, { recursive: true });
  }
  writeFileSync(join(assetsDir, 'style.css'), getStylesheet(), 'utf-8');
}

function generateHtmlPage(opts: {
  title: string;
  projectName: string;
  content: string;
  navItems: NavItem[];
  tocHeadings: TocHeading[];
  currentSlug: string;
  pageId: string;
  locale: string;
  s: any;
  basePrefix: string;
  sidebarStructure: any[];
}): string {
  const navHtml = buildNavHtml(opts.navItems);
  const isIndex = opts.currentSlug === 'index';
  const isMemo = opts.currentSlug === 'memo';
  const isSpecialPage = isIndex || isMemo;
  const tocHtml = isSpecialPage ? '' : buildTocHtml(opts.tocHeadings, opts.s);
  const leftSidebarHtml = isSpecialPage ? '' : buildLeftSidebar(opts.sidebarStructure, opts.currentSlug, opts.basePrefix, opts.s);
  const breadcrumbHtml = isSpecialPage ? '' : buildBreadcrumb(opts.sidebarStructure, opts.currentSlug, opts.basePrefix, opts.s);

  let mainContent: string;
  if (isIndex) {
    mainContent = buildDashboardContent(opts.sidebarStructure, opts.basePrefix, opts.projectName, opts.s);
  } else if (isMemo) {
    mainContent = buildMemoPageContent(opts.s);
  } else {
    mainContent = breadcrumbHtml + '\n      <article>\n        ' + opts.content + '\n      </article>';
  }

  const hasLeftSidebar = leftSidebarHtml.length > 0;
  const hasToc = tocHtml.length > 0;
  let layoutClass = 'layout';
  if (isSpecialPage) layoutClass += ' layout-full';
  else if (!hasLeftSidebar && !hasToc) layoutClass += ' layout-single';
  else if (!hasLeftSidebar) layoutClass += ' layout-no-left';
  else if (!hasToc) layoutClass += ' layout-no-toc';

  return `<!DOCTYPE html>
<html lang="${opts.locale}" data-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapeHtml(opts.title)} - ${escapeHtml(opts.projectName)}</title>
  <link rel="stylesheet" href="${opts.basePrefix}assets/style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github.min.css" media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github-dark.min.css" media="(prefers-color-scheme: dark)">
  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true, theme: 'default' });
  </script>
</head>
<body>
  <header class="header">
    <div class="header-inner">
      <a href="${opts.basePrefix}index.html" class="logo">${escapeHtml(opts.projectName)}</a>
      <button class="mobile-menu-toggle" id="mobileMenuToggle" aria-label="Toggle menu">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/>
        </svg>
      </button>
      <nav class="top-nav" id="topNav">
        <ul class="top-nav-list">
          ${navHtml}
        </ul>
      </nav>
      <div class="header-actions">
        <button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle theme">
          <svg class="sun-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="5"/><path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/></svg>
          <svg class="moon-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
        </button>
      </div>
    </div>
  </header>
  <div class="${layoutClass}">
    ${leftSidebarHtml}
    <main class="content">
      ${mainContent}
      <footer class="footer">
        <p>Generated by <a href="https://github.com/jay05410/codedocs">CodeDocs</a></p>
      </footer>
    </main>
    ${tocHtml}
  </div>

  <!-- Memo: sticky notes container -->
  <div id="memoStickyContainer"></div>

  <!-- Memo: right-click context menu -->
  <div class="codedocs-context-menu" id="memoContextMenu" style="display:none">
    <div class="codedocs-context-menu-item" id="memoContextAdd">${escapeHtml(opts.s.memo.contextAddMemo)}</div>
  </div>

  <!-- Memo: bottom-right controls -->
  <div class="codedocs-memo-controls">
    <button class="codedocs-memo-visibility-btn" id="memoVisibilityBtn" aria-label="${escapeHtml(opts.s.memo.toggleVisibility)}" title="${escapeHtml(opts.s.memo.toggleVisibility)}">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
    </button>
    <button class="codedocs-memo-button" id="memoToggleBtn" aria-label="${escapeHtml(opts.s.memo.title)}">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z" fill="currentColor"/>
      </svg>
      <span class="codedocs-memo-badge" id="memoBadge" style="display:none">0</span>
    </button>
  </div>

  <!-- Memo: manager panel -->
  <div class="codedocs-memo-panel" id="memoPanel" style="display:none">
    <div class="codedocs-memo-panel-header">
      <h3>${escapeHtml(opts.s.memo.title)}</h3>
      <div class="codedocs-memo-panel-actions">
        <button class="codedocs-memo-icon-btn" id="memoPanelCopy" title="${escapeHtml(opts.s.memoPage?.copyJson || 'Copy JSON')}">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
        </button>
        <button class="codedocs-memo-icon-btn" id="memoExportBtn" title="${escapeHtml(opts.s.memo.exportAll)}">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
        </button>
        <input type="file" id="memoFileInput" accept=".json" style="display:none" aria-label="${escapeHtml(opts.s.memo.importFile)}">
      </div>
      <button class="codedocs-memo-close" id="memoCloseBtn" aria-label="Close">&times;</button>
    </div>
    <div class="codedocs-memo-panel-filters">
      <button class="codedocs-memo-toggle-btn active" id="memoFilterToggle">${escapeHtml(opts.s.memo.currentPageOnly || 'Current Page Only')}</button>
    </div>
    <div class="codedocs-memo-list" id="memoList"></div>
  </div>

  ${renderRuntimeScripts(opts)}

</body>
</html>`;
}
